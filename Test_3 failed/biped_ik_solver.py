"""
Biped Robot IK Solver - Convert Foot Trajectories to Joint Angles
===================================================================

Solves inverse kinematics for 3-DOF legs to track the sinusoidal
foot trajectories generated by biped_10step_sinusoidal.py

Uses MuJoCo's forward kinematics for accurate 3D geometry matching.
"""

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.gridspec import GridSpec
from scipy.optimize import minimize
import mujoco
from pathlib import Path


class Biped3DOF_IKSolver:
    """Inverse kinematics solver for 3-DOF biped legs."""
    
    def __init__(self):
        """Initialize solver with robot dimensions and MuJoCo model."""
        # Robot dimensions
        self.link_2_length = 0.014  # Thigh (14mm)
        self.link_1_length = 0.014  # Shin (14mm)
        self.total_length = 0.028
        
        # Hip position
        self.hip_height = 0.42
        self.standing_height = 0.431  # MuJoCo model: foot at Z=0.431 when all joints=0
        
        # MuJoCo model structural offset (link_2 body Z position relative to hip)
        self.link_2_z_offset = 0.034295  # 34.3mm from hip to link_2 base
        
        # Load MuJoCo model for accurate FK
        model_path = Path(__file__).parent / "legged_robot_ik.xml"
        self.model = mujoco.MjModel.from_xml_path(str(model_path))
        self.data = mujoco.MjData(self.model)
        
        # Get body IDs
        self.foot_1_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, 'foot_1')
        self.foot_2_id = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, 'foot_2')
        
        # Joint indices
        self.joint_indices_left = [3, 4, 5]    # Left leg: hip, knee, ankle
        self.joint_indices_right = [6, 7, 8]   # Right leg: hip, knee, ankle
        
        print("="*70)
        print("BIPED 3-DOF INVERSE KINEMATICS SOLVER")
        print("="*70)
        print(f"\nüìê Robot Config:")
        print(f"   Link 2 (Thigh): {self.link_2_length*1000:.0f}mm")
        print(f"   Link 1 (Shin):  {self.link_1_length*1000:.0f}mm")
        print(f"   Hip Height:     {self.hip_height*1000:.0f}mm")
        print(f"   Standing Height: {self.standing_height*1000:.0f}mm")
        print(f"   Link_2 Z Offset: {self.link_2_z_offset*1000:.1f}mm (MuJoCo model structure)")
        print(f"   Using MuJoCo FK for accurate 3D geometry")
    
    def forward_kinematics_mujoco(self, joint_angles, leg='left'):
        """
        Compute foot position using MuJoCo FK.
        
        Args:
            joint_angles: [hip_angle, knee_angle, ankle_angle] in radians
            leg: 'left' or 'right'
            
        Returns:
            [x, z] foot position in world frame
        """
        # Set joint angles
        if leg == 'left':
            indices = self.joint_indices_left
        else:
            indices = self.joint_indices_right
        
        for i, joint_idx in enumerate(indices):
            self.data.qpos[joint_idx] = joint_angles[i]
        
        # Compute forward kinematics
        mujoco.mj_forward(self.model, self.data)
        
        # Get foot position
        if leg == 'left':
            foot_pos = self.data.xpos[self.foot_1_id]
        else:
            foot_pos = self.data.xpos[self.foot_2_id]
        
        return np.array([foot_pos[0], foot_pos[2]])  # [x, z]
    
    def forward_kinematics(self, joint_angles, leg='left'):
        """
        Wrapper for MuJoCo FK (for compatibility).
        """
        return self.forward_kinematics_mujoco(joint_angles, leg)
    
    def jacobian_numerical(self, joint_angles, leg='left', delta=0.0001):
        """
        Compute numerical Jacobian using finite differences.
        
        Args:
            joint_angles: [hip_angle, knee_angle, ankle_angle]
            leg: 'left' or 'right'
            delta: Perturbation size
            
        Returns:
            2x3 Jacobian matrix
        """
        jacobian = np.zeros((2, 3))
        base_pos = self.forward_kinematics(joint_angles, leg)
        
        for i in range(3):
            perturbed = joint_angles.copy()
            perturbed[i] += delta
            perturbed_pos = self.forward_kinematics(perturbed, leg)
            jacobian[:, i] = (perturbed_pos - base_pos) / delta
        
        return jacobian
    
    def jacobian_analytical(self, joint_angles, leg='left'):
        """
        Compute Jacobian using numerical differentiation (more reliable with MuJoCo FK).
        """
        return self.jacobian_numerical(joint_angles, leg)
    
    def ik_damped_least_squares(self, target_pos, initial_angles, leg='left',
                                damping=0.01, max_iter=200, tolerance=0.001):
        """
        Solve IK using Damped Least Squares (Levenberg-Marquardt).
        Best for real-time control - stable and fast.
        
        Args:
            target_pos: [x, z] target foot position
            initial_angles: Initial guess for joint angles
            leg: 'left' or 'right'
            damping: Damping factor (higher = more stable, slower convergence)
            max_iter: Maximum iterations
            tolerance: Convergence threshold (0.001 = 1mm for 28mm leg)
            
        Returns:
            Dictionary with solution, error, iterations, converged
        """
        angles = initial_angles.copy()
        error_history = []
        
        for iteration in range(max_iter):
            # Forward kinematics
            current_pos = self.forward_kinematics(angles, leg)
            
            # Error
            error = target_pos - current_pos
            error_mag = np.linalg.norm(error)
            error_history.append(error_mag)
            
            # Check convergence
            if error_mag < tolerance:
                return {
                    'angles': angles,
                    'error': error_mag,
                    'iterations': iteration + 1,
                    'converged': True,
                    'error_history': error_history
                }
            
            # Jacobian (2x3)
            J = self.jacobian_analytical(angles, leg)
            
            # Damped least squares update
            # J^T (J J^T + ŒªI)^-1
            JJT = J @ J.T
            identity = np.eye(2)
            try:
                inv_term = np.linalg.inv(JJT + damping * identity)
                delta_theta = J.T @ inv_term @ error
            except np.linalg.LinAlgError:
                # Singular matrix - stop
                break
            
            # Update angles
            angles += delta_theta
            
            # Limit joint ranges (optional)
            angles[0] = np.clip(angles[0], -1.57, 1.57)    # Hip: ¬±90¬∞
            angles[1] = np.clip(angles[1], -2.0944, 1.0472) # Knee: -120¬∞ to +60¬∞
            angles[2] = np.clip(angles[2], -1.57, 1.57)     # Ankle: ¬±90¬∞
        
        # Didn't converge but return best solution
        current_pos = self.forward_kinematics(angles)
        final_error = np.linalg.norm(target_pos - current_pos)
        
        return {
            'angles': angles,
            'error': final_error,
            'iterations': max_iter,
            'converged': False,
            'error_history': error_history
        }
    
    def ik_scipy_optimize(self, target_pos, initial_angles, leg='left', max_iter=500):
        """
        Solve IK using SciPy optimization (most reliable but slow).
        
        Args:
            target_pos: [x, z] target foot position
            initial_angles: Initial guess
            leg: 'left' or 'right'
            max_iter: Maximum iterations
            
        Returns:
            Dictionary with solution
        """
        def objective(angles):
            pos = self.forward_kinematics(angles, leg)
            error = np.sum((target_pos - pos)**2)
            return error
        
        result = minimize(objective, initial_angles, method='BFGS',
                         options={'maxiter': max_iter, 'gtol': 1e-8})
        
        return {
            'angles': result.x,
            'error': np.sqrt(result.fun),
            'iterations': result.nit,
            'converged': result.success,
            'error_history': []
        }
    
    def solve_trajectory(self, foot_trajectory, times, hip_height, leg='left', method='dls', 
                        use_warm_start=True):
        """
        Solve IK for complete foot trajectory.
        
        Args:
            foot_trajectory: Nx3 array of [x, y, z] positions (absolute coordinates)
            times: N array of times
            hip_height: Height of hip from floor
            leg: 'left' or 'right'
            method: 'dls' (fast) or 'scipy' (accurate)
            use_warm_start: Use previous solution as initial guess
            
        Returns:
            Dictionary with joint angles and statistics
        """
        n_points = len(foot_trajectory)
        joint_angles = np.zeros((n_points, 3))
        errors = np.zeros(n_points)
        convergence = np.zeros(n_points, dtype=bool)
        iterations = np.zeros(n_points, dtype=int)
        
        # Initial guess (standing position)
        current_angles = np.array([0.0, 0.0, 0.0])
        
        print(f"\nüîÑ Solving IK for {n_points} trajectory points ({leg} leg, {method.upper()})...")
        
        for i, target_pos in enumerate(foot_trajectory):
            # Use world coordinates directly
            target_3d = target_pos[[0, 2]]  # Get x and z from 3D position
            
            if method == 'dls':
                result = self.ik_damped_least_squares(
                    target_3d, 
                    current_angles if use_warm_start else np.array([0.0, 0.0, 0.0]),
                    leg=leg,
                    damping=0.01,
                    max_iter=200
                )
            else:  # scipy
                result = self.ik_scipy_optimize(
                    target_3d,
                    current_angles if use_warm_start else np.array([0.0, 0.0, 0.0]),
                    leg=leg,
                    max_iter=100
                )
            
            joint_angles[i] = result['angles']
            errors[i] = result['error']
            convergence[i] = result['converged']
            iterations[i] = result['iterations']
            
            # Warm start for next point
            current_angles = result['angles'].copy()
            
            if (i + 1) % 100 == 0 or i == n_points - 1:
                print(f"   Progress: {i+1}/{n_points} | Avg error: {np.mean(errors[:i+1])*1000:.3f}mm")
        
        # Statistics
        convergence_rate = np.sum(convergence) / n_points * 100
        avg_error = np.mean(errors)
        max_error = np.max(errors)
        
        print(f"\n‚úÖ IK Solving Complete:")
        print(f"   Convergence rate: {convergence_rate:.1f}%")
        print(f"   Average error: {avg_error*1000:.3f}mm")
        print(f"   Max error: {max_error*1000:.3f}mm")
        print(f"   Avg iterations: {np.mean(iterations):.1f}")
        
        return {
            'joint_angles': joint_angles,
            'errors': errors,
            'convergence': convergence,
            'iterations': iterations,
            'convergence_rate': convergence_rate,
            'avg_error': avg_error,
            'max_error': max_error
        }
    
    def plot_ik_results(self, left_ik_result, right_ik_result, times, 
                       save_path=None):
        """Create comprehensive IK results visualization."""
        fig = plt.figure(figsize=(16, 12))
        gs = GridSpec(4, 2, figure=fig, hspace=0.35, wspace=0.3)
        
        left_angles = left_ik_result['joint_angles']
        right_angles = right_ik_result['joint_angles']
        left_errors = left_ik_result['errors']
        right_errors = right_ik_result['errors']
        
        # ===== Joint Angles =====
        joint_names = ['Hip', 'Knee', 'Ankle']
        colors_left = ['#1f77b4', '#2ca02c', '#ff7f0e']
        colors_right = ['#d62728', '#9467bd', '#8c564b']
        
        for j in range(3):
            ax = fig.add_subplot(gs[0, 0] if j == 0 else (gs[0, 1] if j == 1 else gs[1, 0]))
            if j == 0:
                ax = fig.add_subplot(gs[0, 0])
            elif j == 1:
                ax = fig.add_subplot(gs[0, 1])
            else:
                ax = fig.add_subplot(gs[1, 0])
            
            ax.plot(times, np.degrees(left_angles[:, j]), color=colors_left[j], 
                   linewidth=2, label='Left', linestyle='-')
            ax.plot(times, np.degrees(right_angles[:, j]), color=colors_right[j], 
                   linewidth=2, label='Right', linestyle='-')
            ax.set_xlabel('Time [s]', fontsize=10)
            ax.set_ylabel('Angle [¬∞]', fontsize=10)
            ax.set_title(f'{joint_names[j]} Joint Angles', fontsize=11, fontweight='bold')
            ax.grid(True, alpha=0.3)
            ax.legend(fontsize=9)
        
        # ===== IK Error =====
        ax_err = fig.add_subplot(gs[1, 1])
        ax_err.plot(times, left_errors*1000, 'b-', linewidth=1.5, label='Left', alpha=0.7)
        ax_err.plot(times, right_errors*1000, 'r-', linewidth=1.5, label='Right', alpha=0.7)
        ax_err.set_xlabel('Time [s]', fontsize=10)
        ax_err.set_ylabel('IK Error [mm]', fontsize=10)
        ax_err.set_title('IK Solving Error', fontsize=11, fontweight='bold')
        ax_err.grid(True, alpha=0.3)
        ax_err.legend(fontsize=9)
        
        # ===== Error Histogram =====
        ax_hist = fig.add_subplot(gs[2, 0])
        ax_hist.hist(left_errors*1000, bins=20, alpha=0.6, label='Left', color='blue', edgecolor='black')
        ax_hist.hist(right_errors*1000, bins=20, alpha=0.6, label='Right', color='red', edgecolor='black')
        ax_hist.set_xlabel('Error [mm]', fontsize=10)
        ax_hist.set_ylabel('Frequency', fontsize=10)
        ax_hist.set_title('Error Distribution', fontsize=11, fontweight='bold')
        ax_hist.legend(fontsize=9)
        ax_hist.grid(True, alpha=0.3, axis='y')
        
        # ===== Convergence Analysis =====
        ax_conv = fig.add_subplot(gs[2, 1])
        left_conv = left_ik_result['convergence'].astype(float)
        right_conv = right_ik_result['convergence'].astype(float)
        conv_window = 20
        left_conv_rate = np.convolve(left_conv, np.ones(conv_window)/conv_window, mode='valid')*100
        right_conv_rate = np.convolve(right_conv, np.ones(conv_window)/conv_window, mode='valid')*100
        time_window = times[conv_window//2:len(times)-conv_window//2+1]
        ax_conv.plot(time_window, left_conv_rate, 'b-', linewidth=2, label='Left')
        ax_conv.plot(time_window, right_conv_rate, 'r-', linewidth=2, label='Right')
        ax_conv.set_xlabel('Time [s]', fontsize=10)
        ax_conv.set_ylabel('Convergence %', fontsize=10)
        ax_conv.set_title('Convergence Rate (Rolling Average)', fontsize=11, fontweight='bold')
        ax_conv.set_ylim([0, 105])
        ax_conv.grid(True, alpha=0.3)
        ax_conv.legend(fontsize=9)
        
        # ===== Statistics Box =====
        ax_stats = fig.add_subplot(gs[3, :])
        ax_stats.axis('off')
        
        stats_text = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                                          IK SOLVER STATISTICS - 10-STEP SINUSOIDAL GAIT                              ‚ïë
‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£
‚ïë                                                                                                                       ‚ïë
‚ïë  LEFT LEG:                                             RIGHT LEG:                                                  ‚ïë
‚ïë    ‚Ä¢ Convergence Rate: {left_ik_result['convergence_rate']:6.1f}%                          ‚Ä¢ Convergence Rate: {right_ik_result['convergence_rate']:6.1f}%                    ‚ïë
‚ïë    ‚Ä¢ Average Error:    {left_ik_result['avg_error']*1000:6.3f} mm                        ‚Ä¢ Average Error:    {right_ik_result['avg_error']*1000:6.3f} mm              ‚ïë
‚ïë    ‚Ä¢ Max Error:        {left_ik_result['max_error']*1000:6.3f} mm                        ‚Ä¢ Max Error:        {right_ik_result['max_error']*1000:6.3f} mm              ‚ïë
‚ïë    ‚Ä¢ Avg Iterations:   {np.mean(left_ik_result['iterations']):6.1f}                           ‚Ä¢ Avg Iterations:   {np.mean(right_ik_result['iterations']):6.1f}                    ‚ïë
‚ïë                                                                                                                       ‚ïë
‚ïë  JOINT ANGLE RANGES:                                   METHOD: Damped Least Squares (DLS)                           ‚ïë
‚ïë    ‚Ä¢ Hip:   {np.degrees(np.min(left_angles[:, 0])):+7.1f}¬∞ to {np.degrees(np.max(left_angles[:, 0])):+7.1f}¬∞                    ‚Ä¢ Real-time capable, good for simulation                  ‚ïë
‚ïë    ‚Ä¢ Knee:  {np.degrees(np.min(left_angles[:, 1])):+7.1f}¬∞ to {np.degrees(np.max(left_angles[:, 1])):+7.1f}¬∞                    ‚Ä¢ Stable convergence with damping factor                  ‚ïë
‚ïë    ‚Ä¢ Ankle: {np.degrees(np.min(left_angles[:, 2])):+7.1f}¬∞ to {np.degrees(np.max(left_angles[:, 2])):+7.1f}¬∞                    ‚Ä¢ Warm-start from previous solutions                     ‚ïë
‚ïë                                                                                                                       ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
        """
        
        ax_stats.text(0.5, 0.5, stats_text, transform=ax_stats.transAxes,
                     fontsize=8.5, verticalalignment='center', horizontalalignment='center',
                     family='monospace',
                     bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.3))
        
        plt.suptitle('Biped 3-DOF IK Solver - 10-Step Sinusoidal Walking',
                    fontsize=14, fontweight='bold', y=0.995)
        
        if save_path:
            plt.savefig(save_path, dpi=150, bbox_inches='tight')
            print(f"\n‚úÖ Saved: {save_path}")
        
        return fig


def main():
    """Solve IK for 10-step sinusoidal walking trajectories."""
    
    # Load trajectories
    print("\nüìÇ Loading trajectories...")
    traj_data = np.load('biped_10step_sinusoidal.npy', allow_pickle=True).item()
    
    left_traj = traj_data['left_trajectory']
    right_traj = traj_data['right_trajectory']
    times = traj_data['times']
    
    print(f"   Loaded {len(left_traj)} trajectory points")
    print(f"   Time range: 0-{times[-1]:.2f}s")
    
    # Initialize solver
    solver = Biped3DOF_IKSolver()
    
    # Solve IK for both legs
    print("\n" + "="*70)
    print("SOLVING INVERSE KINEMATICS")
    print("="*70)
    
    left_ik_result = solver.solve_trajectory(
        left_traj, times, solver.hip_height, leg='left', method='dls', use_warm_start=True
    )
    
    right_ik_result = solver.solve_trajectory(
        right_traj, times, solver.hip_height, leg='right', method='dls', use_warm_start=True
    )
    
    # Plot results
    print("\nüìä Creating visualizations...")
    solver.plot_ik_results(left_ik_result, right_ik_result, times,
                          save_path='biped_ik_solutions.png')
    
    # Save results
    print("\nüíæ Saving IK solutions...")
    ik_data = {
        'left_joint_angles': left_ik_result['joint_angles'],
        'right_joint_angles': right_ik_result['joint_angles'],
        'left_errors': left_ik_result['errors'],
        'right_errors': right_ik_result['errors'],
        'left_convergence': left_ik_result['convergence'],
        'right_convergence': right_ik_result['convergence'],
        'times': times,
        'robot_config': {
            'link_2_length': solver.link_2_length,
            'link_1_length': solver.link_1_length,
            'hip_height': solver.hip_height
        }
    }
    np.save('biped_ik_solutions.npy', ik_data)
    print("‚úÖ Saved: biped_ik_solutions.npy")
    
    # Print summary
    print("\n" + "="*70)
    print("SUMMARY")
    print("="*70)
    print(f"‚úÖ Solved IK for 10-step sinusoidal walking")
    print(f"‚úÖ Left leg convergence: {left_ik_result['convergence_rate']:.1f}%")
    print(f"‚úÖ Right leg convergence: {right_ik_result['convergence_rate']:.1f}%")
    print(f"‚úÖ Average errors: {left_ik_result['avg_error']*1000:.3f}mm (L), {right_ik_result['avg_error']*1000:.3f}mm (R)")
    print(f"‚úÖ Joint angles saved with trajectories")
    print("="*70)
    
    plt.show()


if __name__ == "__main__":
    main()
